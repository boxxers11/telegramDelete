from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from pydantic import BaseModel
from typing import Optional, List
import logging
import asyncio
import os
from app.account_deleter import AccountDeleter

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# Mount static files
app.mount("/static", StaticFiles(directory="app/static"), name="static")

# Templates
templates = Jinja2Templates(directory="app/templates")

# Pydantic models
class CreateAccountRequest(BaseModel):
    phone: str

class ConnectAccountRequest(BaseModel):
    code: Optional[str] = None
    phone_code_hash: Optional[str] = None
    password: Optional[str] = None

class ConnectRequest(BaseModel):
    phone: str

# Global account deleter instance
account_deleter = AccountDeleter()

@app.get("/", response_class=HTMLResponse)
async def read_root(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})

@app.post("/accounts")
async def create_account(data: CreateAccountRequest):
    try:
        logger.info(f"Creating account for phone: {data.phone}")
        result = await account_deleter.create_account(data.phone)
        logger.info(f"Account creation result: {result}")
        return result
    except Exception as e:
        logger.error(f"Error creating account: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/accounts")
async def get_accounts():
    try:
        accounts = await account_deleter.get_accounts()
        return {"accounts": accounts}
    except Exception as e:
        logger.error(f"Error getting accounts: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/accounts/{account_id}/connect")
async def connect_account(account_id: str, data: ConnectAccountRequest):
    try:
        logger.info(f"Connecting account {account_id} with data: {data}")
        
        # Get account info
        accounts = await account_deleter.get_accounts()
        account = next((acc for acc in accounts if acc["id"] == account_id), None)
        
        if not account:
            return {"success": False, "error": "Account not found"}
        
        # If code provided, try to sign in with code
        if data.code and data.phone_code_hash:
            logger.info(f"Attempting sign in with code for account {account_id}")
            sign_in_result = await account_deleter.sign_in_with_code(
                account_id=account_id,
                code=data.code,
                phone_code_hash=data.phone_code_hash,
                password=data.password
            )
            logger.info(f"Sign in result: {sign_in_result}")
            return sign_in_result
        else:
            # No code provided, send verification code and return phone_code_hash
            logger.info(f"Sending verification code for account {account_id}")
            result = await account_deleter.connect_account(account_id)
            logger.info(f"Connect result: {result}")
            return result
            
    except Exception as e:
        logger.error(f"Error connecting account {account_id}: {str(e)}")
        return {"success": False, "error": str(e)}

@app.delete("/accounts/{account_id}")
async def delete_account(account_id: str):
    try:
        logger.info(f"Deleting account {account_id}")
        result = await account_deleter.delete_account(account_id)
        logger.info(f"Delete result: {result}")
        return result
    except Exception as e:
        logger.error(f"Error deleting account {account_id}: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/connect")
async def connect(data: ConnectRequest):
    try:
        logger.info(f"Connecting to phone: {data.phone}")
        result = await account_deleter.connect_to_phone(data.phone)
        logger.info(f"Connect result: {result}")
        return result
    except Exception as e:
        logger.error(f"Error connecting to phone {data.phone}: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)